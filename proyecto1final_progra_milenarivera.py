# -*- coding: utf-8 -*-
"""Proyecto1FINAL_PROGRA_MilenaRivera.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LzBQHVuMr9W__0sZqk3iao7ZlH2oIolm
"""

# La evaluación de planeación de proyectos es utilizada para lograr objetivos
# específicos dentro de un marco de tiempo definido. Los elementos clave de la
# gestión de proyectos incluyen definir los objetivos del proyecto, crear un
# plan de proyecto, asignar recursos, gestionar riesgos, monitorear el progreso
# y comunicarse con los interesados. La gestión exitosa de proyectos garantiza
# que estos se completen a tiempo.

# Este Proyecto 1 consiste en codificar un algoritmo para ordenar las
# actividades de un proyecto con el fin de elaborarlo en el menor tiempo
# posible. Ahora, las actividades satisfacen restricciones dadas por una
# elación de precedencia, la cual resulta ser transitiva. El programa debe
# retornar el tiempo mínimo necesario para la elaboración de un proyecto, así
# como la lista de sus actividades críticas, dada una tabla de excel que
# contenga las actividades del proyecto, su descripción, sus actividades
# precedentes inmediatas y la duración de cada una de ellas.

from google.colab import drive
drive.mount('/content/drive') #montar en disco duro de manera virtual
import numpy as np
import openpyxl

print('--------------------------------------------------------------------\n'+
      'Este es un programa que dado un archivo .xlsx que contenga un tabla \n'+
      'con las caracteristicas de un proyecto en forma de tabla con \n' +
      'columnas de la forma (Actividad,Descripcion,Precedentes,Duracion) \n'+
      'en ese orden, retornara  un reporte que incluya el tiempo minimo de \n'+
      'elaboracion del proyecto y una lista de actividades criticas \n'+
      '---------------------------------------------------------------------')


class Archivo:
  '''Esta clase Archivo a traves de su metodo 'xlsx_a_diccionario' permitira
  leer el archivo que le den para que el programa pueda utilizar los datos
  contenidos en este.'''

  def __init__(self, archivo):
    '''Este es el inicializador del objeto archivo introducido. Crea tambien
    un diccionario donde se guardaran los datos del archivo.'''
    self.archivo = archivo
    #diccionario donde guardare la informacion que leo del archivo
    self.diccionario = {}

  def xlsx_a_diccionario(self):
    '''Este es el metodo que transforma la informacion en el archivo en un
    diccionario de la forma {Actividad: [Descripcion,[Precedentes],Duracion]}.'''
    self.diccionario = {}
    workbook = openpyxl.load_workbook(self.archivo)
    sheet = workbook.active

    # Obtengo los nombres de las columnas del encabezado
    encabezado = [
        sheet.cell(
            row=1, column=col).value for col in range(1, sheet.max_column + 1)]

    # Recorro las filas para obtener los datos
    for indice_fila in range(2, sheet.max_row + 1):
        actividad = sheet.cell(row=indice_fila, column=1).value
        descripcion = sheet.cell(row=indice_fila, column=2).value
        precedentes = sheet.cell(row=indice_fila, column=3).value
        duracion = sheet.cell(row=indice_fila, column=4).value

        # Separo los precedentes por comas en caso de ser mas de uno
        precedentes_lista = [
            float(p) for p in precedentes.split(',')] if isinstance(
                precedentes, str) else [precedentes]

        # Agrego los datos al diccionario
        self.diccionario[actividad] = [descripcion, precedentes_lista, duracion]

    return self.diccionario

#####

class Directed_graph:
  '''Esta clase incluye todos los atributos y metodos de una grafica que seran
  utilizados para construirla de manera abstracta.'''

  def __init__(self):
    '''Este es el inicializador de la grafica. La inicializa vacia.'''
    self.nodos = [] #se comienza siempre con una grafica vacia
    self.arcos = [] #se llama arcos cuando son aristas dirigidas

  def len_arcos(self):
    '''Este metodo devuelve la longitud de la lista de arcos.'''
    return len(self.arcos)

  def len_nodos(self):
    '''Este metodo devuelve la longitud de la lista de nodos.'''
    return len(self.nodos)

  def antecesores(self, nodo):
    '''Este metodo devuelve una lista que incluye a los nodos antecesores a
    un nodo.'''
    if nodo not in self.nodos:
      print(nodo, 'no pertenece al conjunto de nodos.')
      return []
    else:
      Ant = []
      for x in self.arcos:
        if nodo == x[-1]:
          Ant.append(x[0])
      return Ant

  def sucesores(self, nodo):
    '''Este metodo devuelve una lista que incluye a los nodos sucesores a
    un nodo.'''
    if nodo not in self.nodos:
      print(nodo, 'no pertenece al conjunto de nodos.')
      return []
    else:
      Suc = []
      for x in self.arcos:
        if nodo == x[0]:
          Suc.append(x[-1])
      return Suc

  def add_vertex(self, nodo):
    '''Este metodo permite agregar nodos a la grafica.'''
    if nodo not in self.nodos:
      self.nodos.append(nodo)

  def add_arc(self, arco):
    '''Este metodo permite agregar arcos a la grafica.'''
    if type(arco) == tuple and len(arco) == 2:
    #ya se que es un par ordenado o tupla continua
      if arco[0] in self.nodos and arco[1] in self.nodos:
        self.arcos.append(arco)
      else :
        print('Las entradas no pertenecen a los nodos.')
    else:
      print('El arco no es valido.')

######
class Redes(Directed_graph):
  '''Esta es la clase para construir redes. Dado que hereda de Directed_graph
  su constructor se hereda al igual que los atributos importantes como nodos
  y aristas. Esta clase construye los caminos entre las actividades con su
  metodo creador_arcos.'''

  def ordenamiento_actividades(self, diccionario):
    '''Este metodo me permitira ordenar las actividades de acuerdo a sus
    predecesores, esto me dira el orden en el que 'se debe' elaborar la red.
    Me base en la busqueda en profundidad (DFS) que es un algoritmo que
    comienza en un nodo y 'explora' hacia las conexiones de ese nodo y lleva un
    registro de cual ya visito.'''
    self.diccionario = diccionario
    self.orden_actividades = []
    visitados = set()

    def algoritmo_dept_first_search(actividad):
        if actividad not in visitados:
            visitados.add(actividad)
            # Verificar si la actividad tiene predecesores
            if actividad in self.diccionario and self.diccionario[
                actividad][1] is not None:
                predecesores = self.diccionario[actividad][1]
                for predecesor in predecesores:
                    algoritmo_dept_first_search(predecesor)
            # Agregar la actividad al orden solo si tiene predecesores definidos
            if actividad in diccionario:
                self.orden_actividades.append(actividad)

    for actividad in diccionario:
        algoritmo_dept_first_search(actividad)

    return self.orden_actividades

  def crear_lista_adyacencia(self, diccionario):
    '''Este metodo permite obtener un diccionario donde se incluyen las
    actividades 'adyacentes' a otra actividad y permitira crear la red.'''
    self.lista_adyacencia = {} #es un diccionario {actividad: [adyacentes]}
    for clave, valor in diccionario.items():
        nodo = clave
        vecinos = valor[1]
        if nodo not in self.lista_adyacencia:
            self.lista_adyacencia[nodo] = []
        for vecino in vecinos:
            if vecino is not None:  # Ignora los vecinos 'None'
                self.lista_adyacencia[nodo].append(vecino)
    return self.lista_adyacencia

  def determinador_subsecuentes(self, dic):
    '''Este metodo permite dereminar los subsecuentes de una actividad a partir
    de un diccionario de adyacencia.'''
    sub = {}
    for a, ps in dic.items(): #creo subsecuentes
      sub[a] = []
      for p in ps:
        sub[p].append(a)
    return sub

  def creador_arcos(self, dic, sub):
    '''Este metodo me permite crear los arcos de la forma {actividad: (nodo
    inicial, nodo final)} y los guarda en un diccionario. Ademas, uno de sus
    atributos sera la lista completa de arcos que incluiran los arcos
    ficticios. '''
    self.arcs = {}
    #los inicializo por default el nodo inicial 0 y el nodo final 1
    self.nodes = [0,1]
    self.done = [[],[]]
    ind = 2 #empiezo a iterar sobre en el indice 2
    self.arrows = [] #esta incluye los arcos ficticios

    for k,v in dic.items():# creo arcos
      #print(k)
      if v == []:
        #print(k)
        self.nodes.append(ind)
        self.arrows.append((0,ind))
        self.done.append([k])
        self.arcs[k] = (0,ind)
        ind += 1
      elif not v in self.done:
        separated = [[elem] for elem in v]
        for elem in separated:
          self.arrows.append((self.done.index(elem),ind))
        self.done.append(v)
        self.nodes.append(ind)
        ind += 1
        if sub[k] == []:
          self.arrows.append((self.done.index(v), ind))
          self.arcs[k]= (self.done.index(v),1)
        else:
          self.nodes.append(ind)
          self.arrows.append((self.done.index(v), ind))
          self.done.append([k])
          self.arcs[k] = (self.done.index(v), ind)
          ind += 1
      else:
        if sub[k] == []:
          self.arrows.append((self.done.index(v), 1)) #lo uno al nodo final
          self.arcs[k] = (self.done.index(v), 1)
        else:
          self.nodes.append(ind)
          self.arrows.append((self.done.index(v), ind))
          self.done.append([k])
          self.arcs[k] = (self.done.index(v), ind)
          ind += 1
    return self.done, self.arrows, self.arcs, self.nodes

  def arcos_creator(self, diccionario_arcos, arcos_totales, diccionario_global):
    '''Este es mi metodo constructor de arcos que devuelve un diccionario
    que contiene toda la informacion necesaria para definir actividades
    criticas de la forma {(nodo inicial, nodo final): (actividad, duracion)}
    a partir de un diccionario de arcos que contenga los nodos de
    donde parte y llega cada uno, una lista de arcos totales en la forma de
    tuplas (nodo inicial, nodo final) y un diccionario global que me permita
    acceder a la duracion de cada actividad.'''
    self.arcos_finales = {}

    for i in arcos_totales:
      for clave, value in diccionario_arcos.items():
        if i == value:
          self.arcos_finales[i] = (clave, diccionario_global[clave][2])

        else: #incluyo arcos ficticios
        #reviso que no hayan sido metidos antes
          if i not in self.arcos_finales.keys():
           #dado que son arcos ficticios solo me interesa duracion = 0
            self.arcos_finales[i] = (None, 0)

    return self.arcos_finales

#####
class Critica:
  '''Esta es la clase para determinar que actividades son criticas. Las
  actividades criticas al igual que las fechas mas lejanas y proximas son sus
  atributos y las guardara en una lista o diccionario.'''

  def __init__(self):
    '''Este es el contructor de las actividades criticas.'''
    self.fmp = {}# Diccionario para almacenar la FMP de cada actividad
    self.fml = {}# Diccionario para almacenar la FML de cada actividad
    self.holgura = {}# Diccionario para almacenar la holgura de cada actividad
    self.actividades_criticas = []

  def calcular_fecha_mas_proxima(self, nodo, arcos, antecesores_nodo):
    '''Este metodo a partir de un diccionario de arcos, y antecesores de un
    nodo calcula las fechas mas proximas este.'''

    if nodo == 0: #nodo inicial
      self.fmp[nodo] = 0
    else:
      #reorro los antecesores
      comparacion =[]#lista donde guardare calculito
      for ante in antecesores_nodo:
        duracion = arcos[(ante,nodo)][1]
        calculito = self.fmp[ante] + duracion
        comparacion.append(calculito)
        self.fmp[nodo] = np.max(comparacion)

    return self.fmp

  def calcular_fecha_mas_lejana(self, nodo, arcos, sucesores_nodo):
    '''Este es el metodo que a partir de un diccionario de arcos y una lista
    de sucesores de un nodo calcula las fechas mas lejanas un nodo
    especifico.'''
    # Obtener el número total de nodos
    num_nodos = max(max(arco) for arco in arcos.keys())

    if nodo == 1: #mi nodo final siempre sera 1 por construccion
      self.fml[nodo] = self.fmp[nodo]
    else: #recuerda voy de reversa
      comparacion = [] #guardare calculito
      for suc in sucesores_nodo:
        duracion = arcos[(nodo, suc)][1]
        calculito = self.fml[suc] - duracion
        comparacion.append(calculito)
        self.fml[nodo] = np.min(comparacion)

    return self.fml

  def holguraaa(self, arcos):
    '''Este metodo calcula la holgura de cada actividad y devuelve un
    diccionario donde guardara la actividad como llave y su holgura como
    valor.'''
    for (nodo_inicial, nodo_final), (actividad, duracion) in arcos.items():
      self.holgura[actividad] = self.fml[nodo_final] - self.fmp[nodo_inicial] - duracion
    return self.holgura

  def es_actividad_critica(self,arcos):
    '''Este metodo determina si es actividad critica y la agrega al atributo de
    actividades criticas.'''

    for (nodo_inicial, nodo_final), (actividad, duracion) in arcos.items():
        if self.holgura[actividad] == 0 and actividad not in self.actividades_criticas:
          self.actividades_criticas.append(actividad)
    return self.actividades_criticas


######
class Reporte:
  '''Esta clase proporcionara una forma de generar el reporte final a partir de
  la informacion obtenida con el programa.'''

  #informacion_final es un diccionario
  def __init__(self, archivo_de_salida, diccionario):
    '''Este es el inicializador del objeto archivo final.'''
    self.reporte = archivo_de_salida
    self.diccionario = diccionario #este diccionario tiene la info global


  def generar_reporte(self, tiempo_minimo, actividades_criticas):
    '''Este metodo me permite generar un archivo nuevo en la ubicacion que se
    haya especificado como archivo de salida en el inicializador donde
    se escribiran los resultados del programa.'''
    #ordeno mis actividades
    act_ordenadas = list(sorted(actividades_criticas))
    #print('act_ordenadas',act_ordenadas)
    with open(self.reporte, 'w') as archivo:
      archivo.write(f'El tiempo necesario para la elaboracion del proyecto es de {int(tiempo_minimo)} semanas.\n')
      archivo.write('Las actividades criticas son:\n')
      for actividad in act_ordenadas:
        archivo.write(f'{int(actividad)}.'+ f'{self.diccionario[actividad][0]} \n')

#######

#Este es mi programa
def main():
  '''Este es mi programa que retorna el tiempo minimo necesario para la
  elaboracion de un proyecto, asi como la lista de sus actividades criticas.'''

  archive = Archivo('/content/drive/MyDrive/programacion24_2/Creacion_de_la_carrera_de_mat_ap.xlsx')
  #leo el archivo
  dic_resultado = archive.xlsx_a_diccionario()
  #print(dic_resultado)

  #inicializo mi red
  mi_red = Redes()

  #ordeno actividades
  orden_actividades = mi_red.ordenamiento_actividades(dic_resultado)
  #print('orden_actividades', orden_actividades)

  #determino las actividades adyacentes a cada actividad
  lista_adyacencia = mi_red.crear_lista_adyacencia(dic_resultado)
  #print('lista de adyacencia: ',lista_adyacencia)

  #ordeno mi lista de adyacencia segun el orden de las actividades
  lista_ordenada_adyacencia = dict(sorted(lista_adyacencia.items(), key= lambda x: orden_actividades.index(x[0])))
  dic = lista_ordenada_adyacencia

  #determino mis subsecuentes
  subsecuentes = mi_red.determinador_subsecuentes(dic)

  #creo mis arcos
  lista_done, arrows_completos, diccionario_arcos, lista_nodes = mi_red.creador_arcos(dic, subsecuentes)

  #print('done',lista_done)
  #print('arrows',arrows_completos)
  #print('arcs', diccionario_arcos)
  #print('nodes', lista_nodes)

  #creo mis arcos con la forma que necesito y 'tomo en cuenta' los ficticios
  arcos = mi_red.arcos_creator(diccionario_arcos, arrows_completos, dic_resultado)
  #print('arcos: ',arcos)

  #creo mi grafica
  for (nodo_i, nodo_j) in arcos.keys():
    mi_red.add_vertex(nodo_i)
  #añado el ultimo nodo
  for (nodo_i, nodo_j) in arcos.keys():
    if nodo_j not in mi_red.nodos:
      mi_red.add_vertex(nodo_j)
  #print('lista nodos',mi_red.nodos)
  #añado mis arcos
  for i in arcos.keys():
    mi_red.add_arc(i)
  #print('arcos de la grafica', mi_red.arcos)

  #hago un diccionario con sus antecesores
  antecesores ={}
  for nodo in mi_red.nodos:
    antecesor = mi_red.antecesores(nodo)
    antecesores[nodo] = antecesor
  #print('diccionario antecesores', antecesores)

  #ordeno los nodos siguiendo la construccion
  def ordenar_nodos(nodos, antecesores):
    # Lista para almacenar el orden de construccion de los nodos
    orden = []
    # funcion recursiva para agregar nodos al orden segun antecesores
    def agregar_nodos(nodo):
        if nodo not in orden:
            if nodo in antecesores:
                for antecesor in antecesores[nodo]:
                    agregar_nodos(antecesor)
            orden.append(nodo)

    # Agregar nodos al orden de construcción
    for nodo in nodos:
        agregar_nodos(nodo)

    return orden

  orden_nodos =  ordenar_nodos(mi_red.nodos, antecesores)
  #print('orden nodos:', orden_nodos)

  #instancio la clase critica
  objeto_critica = Critica()

  #calculo FMP
  for nodo in orden_nodos:
    #encuentro los antecesores de ese nodo
    antecesor = mi_red.antecesores(nodo)
    objeto_critica.calcular_fecha_mas_proxima(nodo, arcos, antecesor)
  #print('fechas mas proximas',objeto_critica.fmp)

  #calculo FML
  for nodo in list(reversed(orden_nodos)):
    #encuentro los sucesores de ese nodo
    sucesor = mi_red.sucesores(nodo)
    objeto_critica.calcular_fecha_mas_lejana(nodo, arcos, sucesor)
  #print('fechas mas lejanas',objeto_critica.fml)

  #calculo la holgura
  Hij = objeto_critica.holguraaa(arcos)
  #print('holgura', Hij)

  #defino actividades criticas
  critic = objeto_critica.es_actividad_critica(arcos)
  print('actividades criticas',critic)

  #genero mi reporte
  archivo_de_salida = '/content/drive/MyDrive/programacion24_2/ReporteFinal.txt'
  report = Reporte(archivo_de_salida, dic_resultado)
  tiempo_minimo = objeto_critica.fml[1]#mi nodo final siempre es el
  print('tiempo_minimo', tiempo_minimo)
  report.generar_reporte(tiempo_minimo, critic)


if __name__ == "__main__":
  main()